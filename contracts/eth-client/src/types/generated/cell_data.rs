// Generated by Molecule 0.6.1
#![allow(dead_code)]
use molecule :: prelude :: * ;
use super :: basic :: * ;
# [ derive ( Clone ) ] pub struct CellData ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for CellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for CellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for CellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "headers" , self . headers ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: core :: default :: Default for CellData { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 28 , 0 , 0 , 0 , 8 , 0 , 0 , 0 , 20 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , ] ; CellData :: new_unchecked ( v . into ( ) ) } } impl CellData { pub const FIELD_COUNT : usize = 1 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn headers ( & self ) -> Chain { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; Chain :: new_unchecked ( self . 0 . slice ( start .. end ) ) } else { Chain :: new_unchecked ( self . 0 . slice ( start .. ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> CellDataReader < 'r > { CellDataReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for CellData { type Builder = CellDataBuilder ; const NAME : & 'static str = "CellData" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { CellData ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { CellDataReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { CellDataReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . headers ( self . headers ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct CellDataReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for CellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for CellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for CellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "headers" , self . headers ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > CellDataReader < 'r > { pub const FIELD_COUNT : usize = 1 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn headers ( & self ) -> ChainReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; ChainReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { ChainReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for CellDataReader < 'r > { type Entity = CellData ; const NAME : & 'static str = "CellDataReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { CellDataReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( field_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } ChainReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct CellDataBuilder { pub ( crate ) headers : Chain , } impl CellDataBuilder { pub const FIELD_COUNT : usize = 1 ; pub fn headers ( mut self , v : Chain ) -> Self { self . headers = v ; self } } impl molecule :: prelude :: Builder for CellDataBuilder { type Entity = CellData ; const NAME : & 'static str = "CellDataBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . headers . as_slice ( ) . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . headers . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . headers . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; CellData :: new_unchecked ( inner . into ( ) ) } }
